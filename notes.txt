HPC
Programas eficientes

9. Optimización (profiling -> dónde optimizar):

9.1 Banderas de compilación
3 Niveles (-Ox, con x en {0,1,2,3,fast}):
    1: básico
    2: estándar
    3: más rápido pero de cuidado, puede hacer cosas raras.

Programación por bloques (caché CPU) (tamaño bloque ?)


¿cómo puedo sacar el índice 1d para (i,j) con m filas y n columnas. Para el caso de RowMajor tenemos en cuenta el número de columnas
    Estrategia: recordar conversion de binario a decimal.
    1d = id = id(i,j) = i*n^1 + j*n^0
                      = i*n + j
Para calcular la función inversa hago uso del módulo y deel truncamiento para int / int
    i = id / n
    j = id % n

Detalles / trucos:
1. Cosas viejas
2. Lenguaje prog consola
    >> for val in 0 1 2 3 fast; do echo "Optim level: $val"; gcc -O$val file_name; ./a.out; done

Refs:
Donald Knuth


Procesamiento en Parlelo (gnu parallel):
    parallel 'echo 2' ::: 1 // Ejecuta en paralelo
    parallel 'echo {}' ::: 1 2 3 4
    parallel './a.out {}' ::: 2 4 8 16 32 // Ejecuta l programa en paralelo para cada argumento
    parallel 'echo {}' ::: 1 2 3 4 ::: A B C D // TOdas las combinaciones de los posible argumentos

    -- dry-run  para ver que se ejecutaría sin hacerlo  
    WARNING: Cambiar el nombre a los archivos generados según el caso (a.out, .txt) porque todos sobre escribirian en el mismo

    # Multiple parameter sets
        parallel echo "Processing {1} with {2}" ::: file1 file2 file3 ::: option-a option-b

    # Cartesian product of parameters
        parallel "convert {1} -resize {2} resized_{1}" ::: *.jpg ::: 50% 75% 100%

    # Using input files for parameters
        echo -e "param1\nparam2\nparam3" | parallel echo "Processing: {}"
    
    # Limit number of parallel jobs
        parallel -j4 command ::: args

    # Use all available CPU cores
        parallel -j0 command ::: args

    # Run jobs sequentially (useful for debugging)
        parallel -j1 command ::: args

Tarea -> tiempo de ejecución en función de block size para distintas optimizaciones:
    Instrucción parallel
        parallel 'g++ -O{} matmul_block.cpp -o matmul_block_{}.x' ::: 0 1 2 3 fast 
        parallel --progress './matmul_block_{1}.x 1024 {2} 10 >> data_{1}.txt' ::: 0 1 2 3 fast ::: 2 4 8 16 32 64 128 256 512 1024 